import math, time, sys
import matplotlib.pyplot as plt
import numpy as np
sys.setrecursionlimit(1000)

example, readfile1, readfile2, readfile3, readfile4, readfile5 = open('example_input.txt','r'), open('sample_input_1.txt', 'r'), open('sample_input_2.txt', 'r'), open('sample_input_3.txt', 'r'), open('sample_input_4.txt', 'r'), open('sample_input_5.txt', 'r')
example1, input1, input2, input3, input4, input5 = example.readlines(), readfile1.readlines(), readfile2.readlines(), readfile3.readlines(), readfile4.readlines(), readfile5.readlines()

input_files = [example1,input1,input2,input3,input4,input5]
k, r = 6, 4
Tmax = 300

def Data_Processing(RNAseq):
    '''readfiles --> list of lists of RNA sequences

    takes in a list of input file names and converts them into a list with all newline
    whitespaces removed. The number of the list corresponds to position in input_lists
    '''
    Data = {}
    for x in range(0,len(RNAseq)):
        hold = '*' + RNAseq[x].replace('\n','').rstrip()
        Data[x] = [hold[y:y+k] for y in range(0,len(hold)-k+1)]
        
    return Data

def Find_Sequence_Motif(Data, model):
    '''Function allows one to loop over as many input lists as desired and output PFM
        and graph of Expectation Score vs Iteration
    '''
    global offset_matrix
    offset_matrix, E_Score_Array, Iteration_Array, offset_matrix_array = [1 for _ in range(0,len(Data))], [0], [0], [] 

    def Compute_Position_Frequency_Matrix(templist, iteration):
        '''list of lists --> PFMLib(nt) = [freq A, freq C, freq G, freq U]

            Takes in an alignment generated by PFM maniuplation and outputs the frequencies of each base at each position
            stored in a library

            Always stored as a 6X4 matrix
            nt: 1 2 3 4 5 6
          base
              A
              C
              G
              U
        '''
        global PFM
        PFM,missing = {'A': [0 for _ in range(0,k)],'C': [0 for _ in range(0,k)],'G': [0 for _ in range(0,k)],'U': [0 for _ in range(0,k)]}, 0
        for x in range(0,len(templist)):
            if '*' in templist[x]:
                offset_matrix[x] = 1
                missing = missing + 1
                continue
            else:
                for y in range(0,k):
                    PFM[templist[x][y]][y] = PFM[templist[x][y]][y] + 1

        for z in range(0,k):
            for line in PFM:
                PFM[line][z] = round(PFM[line][z]/(len(templist)-missing),r)

        if model == 'GibbsZOOPS' and iteration != '':
            GibbsZOOPS_Optimization(PFM, iteration)
        elif model == 'HardOOPS' or model == 'HardZOOPS':
            HardzOOPS_Optimization(PFM, iteration)
        elif model == 'AnnealZOOPS':
            AnnealZOOPS_Optimization(PFM, iteration)
        else:
            return PFM

    def AnnealZOOPS_Optimization(PFM, iteration):
        '''
        '''
        E_Scores = []
        for x in range(0,len(Data)):
            Sub_E_scores, q = [1.0], [1.0]
            for y in range(1,len(Data[x])):
                Sub_E_scores.append(np.prod([PFM[Data[x][y][z]][z] for z in range(0,k)])/pow(0.25,k))
                q.append(pow(Sub_E_scores[-1],iteration/Tmax))

            choice = np.random.choice(Sub_E_scores, p = [q[a]/sum(q) for a in range(0,len(q))])

            offset_matrix[x] = Sub_E_scores.index(choice)
            E_Scores.append(choice)
        E_Score_Array.append(math.log10(np.prod(E_Scores)))
        Iteration_Array.append(iteration)

        if iteration < Tmax + 1:
            Compute_Position_Frequency_Matrix([Data[x][offset_matrix[x]] for x in range(0,len(Data))],iteration + 1)
        else:
            t1 = time.time()
            Data_Visualization(Iteration_Array,E_Score_Array, offset_matrix, PFM, E_Score_Array[-1], t1)
            
    def GibbsZOOPS_Optimization(PFM,iteration):
        '''
        '''
        E_Scores = []
        for x in range(0,len(Data)):
            Sub_E_scores = [1.0]
            for y in range(1,len(Data[x])):
                Sub_E_scores.append(round(np.prod([PFM[Data[x][y][z]][z] for z in range(0,k)])/pow(0.25,k),r))
            choice = np.random.choice(Sub_E_scores, p = [Sub_E_scores[a]/sum(Sub_E_scores) for a in range(0,len(Sub_E_scores))])
            offset_matrix[x] = Sub_E_scores.index(choice)
            E_Scores.append(choice)
        offset_matrix_array.append(offset_matrix)
        E_Score_Array.append(math.log10(np.prod(E_Scores)))
        Iteration_Array.append(iteration)
                 
        if iteration < Tmax + 1:
            Compute_Position_Frequency_Matrix([Data[h][offset_matrix[h]] for h in range(0,len(Data))],iteration + 1)
        else:
            top_offset, top_score = offset_matrix_array[E_Score_Array.index(max(E_Score_Array))], max(E_Score_Array)
            final_PFM = Compute_Position_Frequency_Matrix([Data[i][top_offset[i]] for i in range(0,len(Data))],'')
            t1 = time.time()
            Data_Visualization(Iteration_Array,E_Score_Array, offset_matrix , PFM, max(E_Score_Array) , t1)

    def HardzOOPS_Optimization(PFM, iteration):
        '''
        '''
        E_Scores, BadOffsets = [], []
        for x in range(0,len(Data)):
            Max_Escore = 0
            for y in range(1,len(Data[x])):
                poverq = np.prod([PFM[Data[x][y][z]][z] for z in range(0,k)])/pow(0.25,k)
                if poverq > Max_Escore:
                    Max_Escore = poverq
                    offset_matrix[x] = y
            if model == 'HardZOOPS' and Max_Escore <= 1.0:
                E_Scores.append(1.0)
                offset_matrix[x] = 0
                BadOffsets.append(x)
            else:
                E_Scores.append(Max_Escore)   

        E_Score = math.log10(np.prod(E_Scores))

        if E_Score > E_Score_Array[-1]:
            E_Score_Array.append(E_Score)
            Iteration_Array.append(iteration)
            Compute_Position_Frequency_Matrix([Data[x][offset_matrix[x]] for x in range(0,len(Data))],iteration + 1)
        else:
            E_Score_Array.append(E_Score)
            Iteration_Array.append(iteration)
            t1 = time.time()
            Data_Visualization(Iteration_Array,E_Score_Array, offset_matrix, PFM, E_Score, t1)

    def Data_Visualization(x, y, offsets, PFMfinal, E_Score_Final, time):
        '''Expectation Array --> Line graph and PFM matrix printing

            Once enough iterations of E score has plateaued then the stop algorithm is triggered in the Evaluate_E function.
            This then passes the necessary information onto the data_visualization function to output data in graphical form.
        '''
        #Outut time to run algorithm
        print(model,'logE(M,o): ', E_Score_Final)
        print('Time elapsed to run algorithm: ', time-t0)
        #Resetting offset matrix outputs to have "0-index formatting". Then out and print final PFM
        print('Offset Matrix: ', offsets)
        print('Final Position Frequency Matrix: ')
        for line in PFMfinal:
            print(line, PFMfinal[line])
        print('\n')
        #Graph E_Scores vs Iterations
        plt.plot(x, y, color = 'b')
        plt.xlabel('Iterations')
        plt.ylabel('log E(M,o) Score')
        plt.title(model + ': log E(M,o) Scores vs Iterations')
        plt.show()

        return None
    
    Compute_Position_Frequency_Matrix([Data[x][offset_matrix[x]] for x in range(0,len(Data))],1)

    return None
